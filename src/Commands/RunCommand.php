<?php
namespace TheCodingMachine\WashingMachine\Commands;

use Gitlab\Client;
use Gitlab\Model\Project;
use Psr\Log\LoggerInterface;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Logger\ConsoleLogger;
use Symfony\Component\Console\Output\OutputInterface;
use TheCodingMachine\WashingMachine\Clover\CloverFile;
use TheCodingMachine\WashingMachine\Clover\Crap4JFile;
use TheCodingMachine\WashingMachine\Clover\CrapMethodMerger;
use TheCodingMachine\WashingMachine\Clover\DiffService;
use TheCodingMachine\WashingMachine\Clover\EmptyCloverFile;
use TheCodingMachine\WashingMachine\Git\GitRepository;
use TheCodingMachine\WashingMachine\Gitlab\BuildNotFoundException;
use TheCodingMachine\WashingMachine\Gitlab\BuildService;
use TheCodingMachine\WashingMachine\Gitlab\MergeRequestNotFoundException;
use TheCodingMachine\WashingMachine\Gitlab\Message;
use TheCodingMachine\WashingMachine\Gitlab\SendCommentService;

class RunCommand extends Command
{
    /**
     * @var LoggerInterface
     */
    private $logger;

    protected function configure()
    {
        $this
            ->setName('run')
            ->setDescription('Analyses the coverage report files and upload the result to Gitlab')
            //->setHelp("This command allows you to create users...")
            ->addOption('clover',
                'c',
                InputOption::VALUE_REQUIRED,
                'The path to the clover.xml file generated by PHPUnit.',
                'clover.xml')
            ->addOption('crap4j',
                'j',
                InputOption::VALUE_REQUIRED,
                'The path to the crap4j.xml file generated by PHPUnit.',
                'crap4j.xml')
            ->addOption('gitlab-url',
                'u',
                InputOption::VALUE_REQUIRED,
                'The Gitlab URL. If not specified, it is deduced from the CI_REPOSITORY_URL environment variable.',
                null)
            ->addOption('gitlab-api-token',
                't',
                InputOption::VALUE_REQUIRED,
                'The Gitlab API token. If not specified, it is fetched from the GITLAB_API_TOKEN environment variable.',
                null)
            /*->addOption('gitlab-project-id',
                'p',
                InputOption::VALUE_REQUIRED,
                'The Gitlab project ID. If not specified, it is fetched from the CI_PROJECT_ID environment variable.',
                null)*/
            ->addOption('gitlab-project-name',
                'p',
                InputOption::VALUE_REQUIRED,
                'The Gitlab project name (in the form "group/name"). If not specified, it is deduced from the CI_PROJECT_DIR environment variable.',
                null)
            ->addOption('commit-sha',
                'r',
                InputOption::VALUE_REQUIRED,
                'The commit SHA. If not specified, it is deduced from the CI_COMMIT_SHA environment variable.',
                null)
            ->addOption('gitlab-job-id',
                'b',
                InputOption::VALUE_REQUIRED,
                'The Gitlab CI build/job id. If not specified, it is deduced from the CI_JOB_ID environment variable.',
                null)
            ->addOption('gitlab-build-name',
                'a',
                InputOption::VALUE_REQUIRED,
                'The Gitlab CI build name (the name of this build in the job). If not specified, it is deduced from the CI_BUILD_NAME environment variable.',
                null)
            ->addOption('gitlab-pipeline-id',
                'e',
                InputOption::VALUE_REQUIRED,
                'The Gitlab CI pipeline ID. If not specified, it is deduced from the CI_PIPELINE_ID environment variable.',
                null)
            ->addOption('job-stage',
                's',
                InputOption::VALUE_REQUIRED,
                'The Gitlab CI job stage. If not specified, it is deduced from the CI_JOB_STAGE environment variable.',
                null)
            ->addOption('file',
                'f',
                InputOption::VALUE_IS_ARRAY | InputOption::VALUE_REQUIRED,
                'Text file to be sent in the merge request comments (can be used multiple times).',
                [])
            ->addOption('open-issue',
                'i',
                InputOption::VALUE_NONE,
                'Opens an issue (if the build is not part of a merge request)')
            ->addOption('add-comments-in-commits',
                null,
                InputOption::VALUE_NONE,
                'Add comments directly in the commit')
        ;
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $this->logger = new ConsoleLogger($output);
        $config = new Config($input);

        $cloverFilePath = $config->getCloverFilePath();

        $cloverFile = null;
        if (file_exists($cloverFilePath)) {
            $cloverFile = CloverFile::fromFile($cloverFilePath, getcwd());
            //$output->writeln(sprintf('Code coverage: %.2f%%', $cloverFile->getCoveragePercentage() * 100));
        }

        $crap4JFilePath = $config->getCrap4JFilePath();

        $crap4jFile = null;
        if (file_exists($crap4JFilePath)) {
            $crap4jFile = Crap4JFile::fromFile($crap4JFilePath);
        }

        $files = $config->getFiles();

        $methodsProvider = null;
        $codeCoverageProvider = null;

        if ($cloverFile !== null && $crap4jFile !== null) {
            $methodsProvider = new CrapMethodMerger($cloverFile, $crap4jFile);
            $codeCoverageProvider = $cloverFile;
        } elseif ($cloverFile !== null) {
            $methodsProvider = $cloverFile;
            $codeCoverageProvider = $cloverFile;
        } elseif ($crap4jFile !== null) {
            $methodsProvider = $crap4jFile;
        } elseif (empty($files)) {
            throw new \RuntimeException('Could not find neither clover file, nor crap4j file for analysis nor files to send in comments. Nothing done. Searched paths: '.$cloverFilePath.' and '.$crap4JFilePath);
        }

        $gitlabApiToken = $config->getGitlabApiToken();

        $gitlabUrl = $config->getGitlabUrl();
        $gitlabApiUrl = $config->getGitlabApiUrl();


        /*$projectId = $input->getOption('gitlab-project-id');
        if ($projectId === null) {
            $projectId = getenv('CI_PROJECT_ID');
            if ($projectId === false) {
                throw new \RuntimeException('Could not find the Gitlab project ID in the "CI_PROJECT_ID" environment variable (usually set by Gitlab CI). Either set this environment variable or pass the ID via the --gitlab-project-id command line option.');
            }
        }*/

        $projectName = $config->getGitlabProjectName();

        $commitSha = $config->getCommitSha();

        $currentBranchName = $config->getCurrentBranchName();

        $client = Client::create($gitlabApiUrl);
        $client->authenticate($gitlabApiToken);

        $diffService = new DiffService(5, 30, 20);

        $sendCommentService = new SendCommentService($client, $diffService);

        // From CI_COMMIT_SHA, we can get the commit ( -> project -> build -> commit )
        // From the merge_requests API, we can get the list of commits for a single merge request
        // Hence, we can find the merge_request matching a build!

        $buildService = new BuildService($client);

        $inMergeRequest = false;

        try {
            $mergeRequest = $buildService->findMergeRequestByCommitSha($projectName, $commitSha);

            $repo = new GitRepository(getcwd());
            $targetCommit = $repo->getLatestCommitForBranch('origin/'.$mergeRequest['target_branch']);
            $lastCommonCommit = $repo->getMergeBase($targetCommit, $commitSha);

            $output->writeln('Pipeline current commit: '.$commitSha, OutputInterface::VERBOSITY_DEBUG);
            $output->writeln('Target branch: '.$mergeRequest['target_branch'], OutputInterface::VERBOSITY_DEBUG);
            $output->writeln('Target commit: '.$targetCommit, OutputInterface::VERBOSITY_DEBUG);
            $output->writeln('Last common commit: '.$lastCommonCommit, OutputInterface::VERBOSITY_DEBUG);

            list($previousCodeCoverageProvider, $previousMethodsProvider) = $this->getMeasuresFromCommit($buildService, $mergeRequest['target_project_id'], $lastCommonCommit, $cloverFilePath, $crap4JFilePath, $config->getJobStage(), $config->getGitlabBuildName(), null);
            //list($previousCodeCoverageProvider, $previousMethodsProvider) = $this->getMeasuresFromBranch($buildService, $mergeRequest['target_project_id'], $mergeRequest['target_branch'], $cloverFilePath, $crap4JFilePath);

            $message = new Message();
            if ($codeCoverageProvider !== null) {
                $message->addCoverageMessage($codeCoverageProvider, $previousCodeCoverageProvider);
            } else {
                $output->writeln('Could not find clover file for code coverage analysis.');
            }
            if ($methodsProvider !== null) {
                $message->addDifferencesHtml($methodsProvider, $previousMethodsProvider, $diffService, $commitSha, $gitlabUrl, $projectName);
            } else {
                $output->writeln('Could not find clover file nor crap4j file for CRAP score analysis.');
            }

            $this->addFilesToMessage($message, $files, $output, $config);

            $client->merge_requests->addNote($projectName, $mergeRequest['iid'], (string) $message);

            $inMergeRequest = true;
        } catch (MergeRequestNotFoundException $e) {
            // If there is no merge request attached to this build, let's skip the merge request comment. We can still make some comments on the commit itself!
            $output->writeln('It seems that this CI build is not part of a merge request.');
        }

        if ($config->isAddCommentsInCommits() || ($config->isOpenIssue() && !$inMergeRequest)) {
            try {
                $targetProjectId = $mergeRequest['target_project_id'] ?? $projectName;
                list($lastCommitCoverage, $lastCommitMethodsProvider) = $this->getMeasuresFromBranch($buildService, $targetProjectId, $currentBranchName, $cloverFilePath, $crap4JFilePath, $config->getJobStage(), $config->getGitlabBuildName(), $config->getGitlabPipelineId());

                if ($config->isAddCommentsInCommits()) {
                    $sendCommentService->sendDifferencesCommentsInCommit($methodsProvider, $lastCommitMethodsProvider, $projectName, $commitSha, $gitlabUrl);
                }

                if ($config->isOpenIssue() && !$inMergeRequest) {
                    $message = new Message();

                    if ($codeCoverageProvider !== null) {
                        $message->addCoverageMessage($codeCoverageProvider, $lastCommitCoverage);
                    } else {
                        $output->writeln('Could not find clover file for code coverage analysis.');
                    }

                    if ($methodsProvider !== null) {
                        $message->addDifferencesHtml($methodsProvider, $lastCommitMethodsProvider, $diffService, $commitSha, $gitlabUrl, $projectName);
                    } else {
                        $output->writeln('Could not find clover file nor crap4j file for CRAP score analysis.');
                    }

                    $this->addFilesToMessage($message, $files, $output, $config);

                    $project = new Project($projectName, $client);

                    $options = [
                        'description' => (string) $message
                    ];

                    $userId = $this->getCommiterId($project, $commitSha);
                    if ($userId !== null) {
                        $options['assignee_id'] = $userId;
                    }

                    $project->createIssue('Build failed', $options);
                }
            } catch (BuildNotFoundException $e) {
                $output->writeln('Unable to find a previous build for this branch. Skipping adding comments inside the commit. '.$e->getMessage());
            }
        }
    }

    /**
     * Returns the user id of the committer.
     *
     * @param Project $project
     * @param string $commitRef
     * @return int|null
     */
    private function getCommiterId(Project $project, $commitRef)
    {

        $commit = $project->commit($commitRef);

        return $commit->committer ? $commit->committer->id :  null;
    }

    /**
     * @param BuildService $buildService
     * @param string $projectName
     * @param string $targetBranch
     * @param string $cloverPath
     * @param string $crap4JPath
     * @return array First element: code coverage, second element: list of methods.
     * @throws BuildNotFoundException
     */
    public function getMeasuresFromBranch(BuildService $buildService, string $projectName, string $targetBranch, string $cloverPath, string $crap4JPath, string $jobStage, string $buildName, string $excludePipelineId) : array
    {
        try {
            $tmpFile = tempnam(sys_get_temp_dir(), 'art').'.zip';

            $buildService->dumpArtifactFromBranch($projectName, $targetBranch, $buildName, $jobStage, $tmpFile, $excludePipelineId);
            $zipFile = new \ZipArchive();
            if ($zipFile->open($tmpFile)!==true) {
                throw new \RuntimeException('Invalid ZIP archive '.$tmpFile);
            }
            return $this->getMeasuresFromZipFile($zipFile, $cloverPath, $crap4JPath);
        } catch (\RuntimeException $e) {
            if ($e->getCode() === 404) {
                // We could not find a previous clover file in the master branch.
                // Maybe this branch is the first to contain clover files?
                // Let's deal with this by generating a fake "empty" clover file.
                $this->logger->info('We could not find a previous clover file in the build attached to branch '.$targetBranch.'. Maybe this commit is the first on this branch?');
                return [EmptyCloverFile::create(), EmptyCloverFile::create()];
            } else {
                throw $e;
            }
        }
    }

    public function getMeasuresFromCommit(BuildService $buildService, string $projectName, string $commitId, string $cloverPath, string $crap4JPath, string $jobStage, string $buildName, ?string $excludePipelineId) : array
    {
        try {
            $tmpFile = tempnam(sys_get_temp_dir(), 'art').'.zip';

            $pipeline = $buildService->getLatestPipelineFromCommitId($projectName, $commitId, $excludePipelineId);
            $buildService->dumpArtifact($projectName, $pipeline['id'], $buildName, $jobStage, $tmpFile);
            $zipFile = new \ZipArchive();
            if ($zipFile->open($tmpFile)!==true) {
                throw new \RuntimeException('Invalid ZIP archive '.$tmpFile);
            }
            return $this->getMeasuresFromZipFile($zipFile, $cloverPath, $crap4JPath);
        } catch (\RuntimeException $e) {
            if ($e->getCode() === 404) {
                // We could not find a previous clover file in the given commit.
                // Maybe this branch is the first to contain clover files?
                // Let's deal with this by generating a fake "empty" clover file.
                $this->logger->warning('We could not find a previous clover file in the build attached to commit '.$commitId.'. Maybe this branch is the first to contain clover files?');
                $this->logger->debug($e->getMessage().' - '.$e->getTraceAsString(), [
                    'exception' => $e
                ]);
                return [EmptyCloverFile::create(), EmptyCloverFile::create()];
            } else {
                throw $e;
            }
        } catch (BuildNotFoundException $e) {
            // Maybe there is no .gitlab-ci.yml file on the target branch? In this case, there is no build.
            $this->logger->warning('We could not find a build for commit '.$commitId.'.');
            return [EmptyCloverFile::create(), EmptyCloverFile::create()];
        }
    }

    private function getMeasuresFromZipFile(\ZipArchive $zipFile, string $cloverPath, string $crap4JPath) : array
    {
        $cloverFileString = $zipFile->getFromName($cloverPath);

        $cloverFile = null;
        if ($cloverFileString !== false) {
            $cloverFile = CloverFile::fromString($cloverFileString, getcwd());
        }

        $crap4JString = $zipFile->getFromName($crap4JPath);

        $crap4JFile = null;
        if ($crap4JString !== false) {
            $crap4JFile = Crap4JFile::fromString($crap4JString);
        }

        $methodsProvider = null;
        $codeCoverageProvider = null;

        if ($cloverFile !== null && $crap4JFile !== null) {
            $methodsProvider = new CrapMethodMerger($cloverFile, $crap4JFile);
            $codeCoverageProvider = $cloverFile;
        } elseif ($cloverFile !== null) {
            $methodsProvider = $cloverFile;
            $codeCoverageProvider = $cloverFile;
        } elseif ($crap4JFile !== null) {
            $methodsProvider = $crap4JFile;
        } else {
            return [EmptyCloverFile::create(), EmptyCloverFile::create()];
        }

        return [$codeCoverageProvider, $methodsProvider];
    }

    private function addFilesToMessage(Message $message, array $files, OutputInterface $output, Config $config) {
        foreach ($files as $file) {
            if (!file_exists($file)) {
                $output->writeln('<error>Could not find file to send "'.$file.'". Skipping this file.</error>');
                continue;
            }

            $message->addFile(new \SplFileInfo($file), $config->getGitlabUrl(), $config->getGitlabProjectName(), $config->getGitlabJobId());
        }
    }
}

/*
=================ENV IN A PR CONTEXT =========================

CI_BUILD_TOKEN=xxxxxx
HOSTNAME=runner-9431b96d-project-428-concurrent-0
PHP_INI_DIR=/usr/local/etc/php
PHP_ASC_URL=https://secure.php.net/get/php-7.0.15.tar.xz.asc/from/this/mirror
CI_BUILD_BEFORE_SHA=7af13f8e3bd090c7c34750e4badfc66a5f0af110
CI_SERVER_VERSION=
CI_BUILD_ID=109
OLDPWD=/
PHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2
PHP_MD5=dca23412f3e3b3987e582091b751925d
CI_PROJECT_ID=428
PHPIZE_DEPS=autoconf 		file 		g++ 		gcc 		libc-dev 		make 		pkg-config 		re2c
PHP_URL=https://secure.php.net/get/php-7.0.15.tar.xz/from/this/mirror
CI_BUILD_REF_NAME=feature/js-ci
CI_BUILD_REF=7af13f8e3bd090c7c34750e4badfc66a5f0af110
PHP_LDFLAGS=-Wl,-O1 -Wl,--hash-style=both -pie
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
CI_BUILD_STAGE=test
CI_PROJECT_DIR=/builds/tcm-projects/uneo
PHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2
GPG_KEYS=1A4E8B7277C42E53DBA9C7B9BCAA30EA9C0D5763 6E4F6AB321FDC07F2C332E3AC2BF0BC433CFC8B3
PWD=/builds/tcm-projects/uneo
CI_DEBUG_TRACE=false
CI_SERVER_NAME=GitLab CI
XDEBUG_VERSION=2.5.0
GITLAB_CI=true
CI_SERVER_REVISION=
CI_BUILD_NAME=test:app
HOME=/root
SHLVL=1
PHP_SHA256=300364d57fc4a6176ff7d52d390ee870ab6e30df121026649f8e7e0b9657fe93
CI_SERVER=yes
CI=true
CI_BUILD_REPO=http://gitlab-ci-token:xxxxxx@git.thecodingmachine.com/tcm-projects/uneo.git
PHP_VERSION=7.0.15

===================ENV IN A COMMIT CONTEXT

CI_BUILD_TOKEN=xxxxxx
HOSTNAME=runner-9431b96d-project-447-concurrent-0
PHP_INI_DIR=/usr/local/etc/php
PHP_ASC_URL=https://secure.php.net/get/php-7.0.15.tar.xz.asc/from/this/mirror
CI_BUILD_BEFORE_SHA=42dd9686eafc2e8fb0a6b4d2c6785baec229c94a
CI_SERVER_VERSION=
CI_BUILD_ID=192
OLDPWD=/
PHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2
PHP_MD5=dca23412f3e3b3987e582091b751925d
CI_PROJECT_ID=447
GITLAB_API_TOKEN=xxxxxxxxxxxxxxchangedmanually
PHPIZE_DEPS=autoconf 		file 		g++ 		gcc 		libc-dev 		make 		pkg-config 		re2c
PHP_URL=https://secure.php.net/get/php-7.0.15.tar.xz/from/this/mirror
CI_BUILD_REF_NAME=master
CI_BUILD_REF=42dd9686eafc2e8fb0a6b4d2c6785baec229c94a
PHP_LDFLAGS=-Wl,-O1 -Wl,--hash-style=both -pie
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
CI_BUILD_STAGE=test
CI_PROJECT_DIR=/builds/dan/washing-test
PHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2
GPG_KEYS=1A4E8B7277C42E53DBA9C7B9BCAA30EA9C0D5763 6E4F6AB321FDC07F2C332E3AC2BF0BC433CFC8B3
PWD=/builds/dan/washing-test
CI_DEBUG_TRACE=false
CI_SERVER_NAME=GitLab CI
XDEBUG_VERSION=2.5.0
GITLAB_CI=true
CI_SERVER_REVISION=
CI_BUILD_NAME=test
HOME=/root
SHLVL=1
PHP_SHA256=300364d57fc4a6176ff7d52d390ee870ab6e30df121026649f8e7e0b9657fe93
CI_SERVER=yes
CI=true
CI_BUILD_REPO=http://gitlab-ci-token:xxxxxx@git.thecodingmachine.com/dan/washing-test.git
PHP_VERSION=7.0.15
*/